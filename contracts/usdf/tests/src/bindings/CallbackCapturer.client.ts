/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.11.1.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import { StdFee } from "@cosmjs/amino";
import { CosmWasmClient, ExecuteResult, SigningCosmWasmClient } from "@cosmjs/cosmwasm-stargate";

import {
  AdminResponse,
  BankMsg,
  BankQuery,
  Binary,
  Coin,
  CosmosMsgForEmpty,
  DistributionMsg,
  Empty,
  ExecuteMsg,
  GovMsg,
  IbcMsg,
  IbcQuery,
  IbcTimeout,
  IbcTimeoutBlock,
  InstantiateMsg,
  QueryMsg,
  QueryRequestForEmpty,
  ReceiveIcaResponseMsg,
  ResultResponse,
  StakingMsg,
  StakingQuery,
  StdAck,
  Timestamp,
  Uint128,
  Uint64,
  VoteOption,
  WasmMsg,
  WasmQuery,
} from "./CallbackCapturer.types";
export interface CallbackCapturerReadOnlyInterface {
  contractAddress: string;
  admin: () => Promise<AdminResponse>;
  result: ({ id }: { id: string }) => Promise<ResultResponse>;
}
export class CallbackCapturerQueryClient implements CallbackCapturerReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.admin = this.admin.bind(this);
    this.result = this.result.bind(this);
  }

  admin = async (): Promise<AdminResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      admin: {},
    });
  };
  result = async ({ id }: { id: string }): Promise<ResultResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      result: {
        id,
      },
    });
  };
}
export interface CallbackCapturerInterface extends CallbackCapturerReadOnlyInterface {
  contractAddress: string;
  sender: string;
  sendMsgs: (
    {
      callbackId,
      channelId,
      msgs,
    }: {
      callbackId: string;
      channelId: string;
      msgs: CosmosMsgForEmpty[];
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>;
  checkRemoteBalance: (
    {
      channelId,
    }: {
      channelId: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>;
  ibcQuery: (
    {
      callbackId,
      channelId,
      msgs,
    }: {
      callbackId: string;
      channelId: string;
      msgs: QueryRequestForEmpty[];
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>;
  sendFunds: (
    {
      icaChannelId,
      transferChannelId,
    }: {
      icaChannelId: string;
      transferChannelId: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>;
  receiveIcaResponse: (
    {
      id,
      msg,
    }: {
      id: string;
      msg: StdAck;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>;
}
export class CallbackCapturerClient extends CallbackCapturerQueryClient implements CallbackCapturerInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.sendMsgs = this.sendMsgs.bind(this);
    this.checkRemoteBalance = this.checkRemoteBalance.bind(this);
    this.ibcQuery = this.ibcQuery.bind(this);
    this.sendFunds = this.sendFunds.bind(this);
    this.receiveIcaResponse = this.receiveIcaResponse.bind(this);
  }

  sendMsgs = async (
    {
      callbackId,
      channelId,
      msgs,
    }: {
      callbackId: string;
      channelId: string;
      msgs: CosmosMsgForEmpty[];
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        send_msgs: {
          callback_id: callbackId,
          channel_id: channelId,
          msgs,
        },
      },
      fee,
      memo,
      funds
    );
  };
  checkRemoteBalance = async (
    {
      channelId,
    }: {
      channelId: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        check_remote_balance: {
          channel_id: channelId,
        },
      },
      fee,
      memo,
      funds
    );
  };
  ibcQuery = async (
    {
      callbackId,
      channelId,
      msgs,
    }: {
      callbackId: string;
      channelId: string;
      msgs: QueryRequestForEmpty[];
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        ibc_query: {
          callback_id: callbackId,
          channel_id: channelId,
          msgs,
        },
      },
      fee,
      memo,
      funds
    );
  };
  sendFunds = async (
    {
      icaChannelId,
      transferChannelId,
    }: {
      icaChannelId: string;
      transferChannelId: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        send_funds: {
          ica_channel_id: icaChannelId,
          transfer_channel_id: transferChannelId,
        },
      },
      fee,
      memo,
      funds
    );
  };
  receiveIcaResponse = async (
    {
      id,
      msg,
    }: {
      id: string;
      msg: StdAck;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        receive_ica_response: {
          id,
          msg,
        },
      },
      fee,
      memo,
      funds
    );
  };
}
